import os
import shutil
import glob
import numpy as np
import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import base64
from helper import process_data, model, read_csv, read_code_file, extract_nodes_with_location_info, \
    create_adjacency_list, create_visual_graph
sns.set_theme(style="darkgrid")
sns.set()
st.set_page_config(layout="wide")

def show_pdf(file_path):
    with open(file_path,"rb") as f:
        base64_pdf = base64.b64encode(f.read()).decode('utf-8')
    pdf_display = f'<iframe src="data:application/pdf;base64,{base64_pdf}" width="100%" height="800" type="application/pdf"></iframe>'
    st.markdown(pdf_display, unsafe_allow_html=True)


def main():
    # Main system
    st.markdown("<div style='text-align: center;'><img style='width: 100px' src='https://upload.wikimedia.org/wikipedia/commons/thumb/1/13/Logo_PTIT_University.png/600px-Logo_PTIT_University.png'/></div>", unsafe_allow_html=True)
    st.markdown("<h1 style='text-align: center;'>Phát hiện lỗ hổng bảo mật dựa trên Học biểu diễn</h1>", unsafe_allow_html=True)
    st.markdown("<p style='text-align: center;'>Sử dụng mã nguồn C/C++ để phân tích và phân loại mã nguồn có chứa lỗ hổng bảo mật hay không?</p>", unsafe_allow_html=True)
    col1, col2 = st.columns(2, gap="medium")
    with col1:
        st.subheader("Mã nguồn để phân tích")
        source_code = st.text_area('Mã nguồn để phân tích', value='', height=400, placeholder='Hãy nhập mã nguồn C/C++ để phân tích', label_visibility='hidden')
        result = st.button('Phân tích mã nguồn')
    with col2:
        st.subheader("Kết quả dự đoán")
        if result and source_code:
            directory = 'tmp'
            output_dir = "output"
            file_name = "source_file.c"

            # Parse code with Joern
            with open(f"tmp/{file_name}", "w") as file:
                file.write(source_code)
            if os.path.exists("parsed"):
                shutil.rmtree("parsed")
            os.system("./joern/joern-parse tmp/")

            # Process data
            data = process_data.handle_cpg(f"parsed/tmp/{file_name}")

            # Predict result
            encode_vectors, embed_vectors, y_probs = model.predict(data, verbose=0)
            y_probs = np.squeeze(y_probs).tolist()
            labels = ['Bình thường', 'Lỗ hổng bảo mật']

            # drawing graphs
            fig, ax = plt.subplots()
            ax = sns.barplot(y=labels, x=y_probs)
            for n, (label, _y) in enumerate(zip(labels, y_probs)):
                ax.annotate(
                    '{:.3f}'.format(abs(_y)),
                    xy=(_y, n),
                    ha='left',
                    va='center',
                    xytext=(5, 0),
                    textcoords='offset points')

            ax.set(xlabel='Độ tin cậy %', ylabel='Mã nguồn')
            st.pyplot(fig)

            # Create visualize cpg graph
            code_file_path = os.path.join(directory, file_name)
            nodes_path = os.path.join('parsed', directory, file_name, 'nodes.csv')
            edges_path = os.path.join('parsed', directory, file_name, 'edges.csv')
            nodes = read_csv(nodes_path)
            edges = read_csv(edges_path)
            code = read_code_file(code_file_path)
            node_indices, node_ids, line_numbers, node_id_to_ln = extract_nodes_with_location_info(nodes)
            adjacency_list = create_adjacency_list(line_numbers, node_id_to_ln, edges, False)
            create_visual_graph(code, adjacency_list, os.path.join(output_dir, file_name), verbose=0)

            # Remove tmp file
            filelist = glob.glob(os.path.join("tmp", "*"))
            for f in filelist:
                os.remove(f)

    if result:
        st.subheader("Đồ thị CPG của mã nguồn sau khi phân tích")
        show_pdf(f'output/{file_name}.pdf')


if __name__ == '__main__':
    main()